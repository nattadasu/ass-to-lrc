"""ASS file generator."""

import logging
from pathlib import Path

from .models import LyricLine, Metadata

logger = logging.getLogger(__name__)


class ASSConverter:
    """Converter for generating ASS files from parsed lyrics."""

    # Default ASS header template
    SCRIPT_INFO = """[Script Info]
; Script generated by ass2lrc
; https://github.com/nattadasu/ass-to-lrc
Title: {title}
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
PlayResX: 640
PlayResY: 360
YCbCr Matrix: None"""

    STYLES_SECTION = """[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,48,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1"""  # noqa: E501

    EVENTS_HEADER = """[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text"""

    def __init__(self, metadata: Metadata | None = None, with_karaoke: bool = True):
        """
        Initialize ASS converter.

        Args:
            metadata: Metadata to include in ASS file
            with_karaoke: Whether to generate karaoke timing tags
        """
        self.metadata = metadata or Metadata()
        self.with_karaoke = with_karaoke

    @staticmethod
    def _format_ass_time(seconds: float) -> str:
        """Format seconds as ASS timestamp H:MM:SS.CC."""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = seconds % 60
        return f"{hours}:{minutes:02d}:{secs:05.2f}"

    def _generate_script_info(self) -> str:
        """Generate [Script Info] section."""
        title = self.metadata.title or "Default Aegisub file"
        return self.SCRIPT_INFO.format(title=title)

    def _calculate_end_times(self, lyrics: list[LyricLine]) -> None:
        """Calculate end times for lyrics based on next line's start time."""
        for i, lyric in enumerate(lyrics):
            # If end_time equals start_time (no proper end time set)
            if lyric.end_time == lyric.start_time:
                if i < len(lyrics) - 1:
                    # Use the start time of the next line
                    lyric.original_end_time = lyrics[i + 1].start_time
                else:
                    # For the last line, add a reasonable duration (2 seconds)
                    lyric.original_end_time = lyric.start_time + 2.0

    def _generate_dialogue_line(self, lyric: LyricLine) -> str:
        """Generate a Dialogue line for ASS format."""
        start = self._format_ass_time(lyric.start_time)
        end = self._format_ass_time(lyric.end_time)
        style = lyric.style or "Default"
        name = lyric.name or ""
        effect = lyric.effect or ""

        # Generate text with karaoke tags if available
        if self.with_karaoke and lyric.syllables:
            text_parts = []
            for syllable in lyric.syllables:
                duration_cs = int(syllable.duration * 100)
                text_parts.append(f"{{\\k{duration_cs}}}{syllable.text}")
            text = "".join(text_parts)
        else:
            text = lyric.text

        return f"Dialogue: 0,{start},{end},{style},{name},0,0,0,{effect},{text}"

    def convert(self, lyrics: list[LyricLine], output_path: Path) -> None:
        """
        Convert lyrics to ASS format and write to file.

        Args:
            lyrics: List of lyric lines to convert
            output_path: Path to write ASS file
        """
        # Calculate proper end times for lines
        self._calculate_end_times(lyrics)

        lines = []

        # Add Script Info
        lines.append(self._generate_script_info())
        lines.append("")

        # Add Styles
        lines.append(self.STYLES_SECTION)
        lines.append("")

        # Add Events header
        lines.append(self.EVENTS_HEADER)

        # Add dialogue lines
        for lyric in lyrics:
            lines.append(self._generate_dialogue_line(lyric))

        # Write to file
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, "w", encoding="utf-8") as f:
            f.write("\n".join(lines) + "\n")
